# Лабораторная работа №4

## Тема

Моделирование задач синхронизации потоков в .NET: «Dining Philosophers, «Sleeping Barber» и «Producer and Consumer». Демонстрация взаимоблокировок и способов их предотвращения, использование примитивов синхронизации `SemaphoreSlim`, `Mutex`, `lock`.

## Цели работы

1. Исследовать проблему взаимоблокировок (deadlock) и starvation.
2. Реализовать многопоточные модели классических задач синхронизации.
3. Показать некорректные и корректные решения, объяснить различия.
4. Настроить автоматизированные тесты для проверки корректности реализации.

## Оборудование и программное обеспечение

- ОС: Windows 11 Home 23H2 (22631.2715)
- Процессор: AMD Ryzen 5 5500U @ 2.30 GHz
- ОЗУ: 8 GB
- .NET SDK: 9.0.100
- Компилятор: Roslyn (.NET 9)
- Режим сборки: `Release`, платформа x64
- Средства тестирования: xUnit, Microsoft.NET.Test.Sdk, coverlet.collector

## Структура проекта

```
lab04/
├─ Lab04.sln
├─ src/
│  └─ Lab04/
│     ├─ Lab04.csproj
│     ├─ DiningPhilosophers/
│     │  ├─ DiningPhilosophersDeadlockSimulation.cs
│     │  └─ DiningPhilosophersResolvedSimulation.cs
│     ├─ SleepingBarber/
│     │  └─ BarberShop.cs
│     └─ ProducerConsumer/
│        └─ ProducerConsumerQueue.cs
└─ tests/
   └─ Lab04.Tests/
      ├─ Lab04.Tests.csproj
      ├─ DiningPhilosophersTests.cs
      ├─ SleepingBarberTests.cs
      └─ ProducerConsumerTests.cs
```

## Краткое описание модулей

### 1. Обедающие философы

- **Версия с deadlock** (`DiningPhilosophersDeadlockSimulation`): каждый философ берёт сначала левую вилку, затем правую — демонстрируется взаимная блокировка.
- **Исправленная версия** (`DiningPhilosophersResolvedSimulation`): упорядоченный захват вилок (всегда сначала вилку с меньшим индексом) предотвращает deadlock и starvation; ведётся учёт количества приёмов пищи.

### 2. Спящий парикмахер

- Модель парикмахерской с ограниченной очередью ожидания.
- Примитивы синхронизации: `SemaphoreSlim` для сигнализации клиентов, `lock` и флаг занятости для контроля очереди, `TaskCompletionSource` для уведомления клиентов.
- Имитация обслуживания: парикмахер спит до появления клиентов, затем обслуживает каждого по очереди.

### 3. Производитель–Потребитель

- Генерический буфер фиксированной ёмкости (`ProducerConsumerQueue<T>`).
- Используются `SemaphoreSlim` для слотов и элементов, `lock` для доступа к очереди.
- Поддерживаются методы `AddAsync`, `TakeAsync`, `CompleteAdding`; корректно обрабатываются ситуации переполнения и опустошения очереди.

## Сборка и запуск

```bash
cd lab04
dotnet restore
dotnet build -c Release
```

## Запуск тестов

```bash
dotnet test -c Release
```

### Результаты тестирования

- `DiningPhilosophersTests`
  - Проверка, что версия с deadlock не завершает работу за заданный таймаут.
  - Проверка, что исправленная версия позволяет каждому философу поесть заданное количество раз.
- `SleepingBarberTests`
  - Подтверждение обслуживания клиентов в пределах вместимости очереди.
- `ProducerConsumerTests`
  - Гарантия передачи всех элементов от производителей к потребителям.
  - Проверка корректного поведения после завершения добавления.

Все тесты завершаются успешно, что подтверждает корректность реализации ключевых сценариев.

## Ответы на контрольные вопросы

1. **Race condition** — состояние гонки, возникающее при неконтролируемом доступе нескольких потоков к общим данным. В задачах лабораторной работы этого удаётся избежать благодаря использованию `SemaphoreSlim`, `lock` и упорядоченному захвату ресурсов.
2. **Deadlock vs Starvation**: deadlock — взаимная блокировка, когда потоки бессрочно ожидают друг друга (демонстрируется в первой версии философов). Starvation — голодание, когда поток постоянно вытесняется другими (может возникнуть у философов при неправильном резервировании ресурсов или у клиентов в очереди парикмахерской без справедливого планирования).
3. **Критическая секция** — участки кода, где происходит доступ к разделяемым данным; в проекте защищаются через `lock` и ожидание семафоров (например, очереди клиентов, буфер производителя–потребителя).
4. **lock vs Monitor** — `lock` является синтаксическим сахаром над `Monitor.Enter/Exit`; добавляет защиту от исключений.  
   **Mutex vs SemaphoreSlim** — `Mutex` может использоваться межпроцессно, `SemaphoreSlim` работает только внутри процесса и легче по ресурсам.  
   **Semaphore vs SemaphoreSlim** — классический `Semaphore` поддерживает межпроцессное взаимодействие и ожидает дескрипторов ОС; `SemaphoreSlim` предназначен для внутрипроцессного сценария и поддерживает асинхронное ожидание.

## Выводы

- Демонстрирована важность строгого порядка захвата ресурсов для предотвращения взаимоблокировок.
- На примере очередей и буферов показано, как разные примитивы синхронизации помогают управлять ограниченными ресурсами в многопоточном окружении.
- Подготовленные автоматизированные тесты позволяют убедиться в корректности логики и служат регрессионной защитой от изменений.
