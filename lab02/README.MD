# Лабораторная работа №2

**Тема:** Работа с коллекциями .NET

## Цель

Проанализировать и сравнить производительность операций над коллекциями `List<T>`, `LinkedList<T>`, `Queue<T>`, `Stack<T>` и `ImmutableList<T>`, а также подготовить автоматизированные тесты корректности.

## Оборудование и ПО

- ОС: Windows 11 Home 23H2 (22631.2715)
- Процессор: AMD RYZEN 5-5500U @ 2.30 GHz
- ОЗУ: 8 GB
- .NET SDK: 9.0.100
- Компилятор: Roslyn (.NET 9)
- Режим запуска: `Release`, 64-bit

## Подход к измерениям

1. **Размер коллекции:** каждая коллекция инициализируется 100 000 элементами.
2. **Количество повторов операции:** 10 000 последовательных действий (добавление, удаление и т.д.) внутри одного прогона.
3. **Число прогонов:** 5, результат — среднее время в миллисекундах.
4. **Замеры:** `System.Diagnostics.Stopwatch`.
5. **Не применимые операции** (например, вставка в середину `Queue`) помечаются как _N/A_.
6. **ImmutableList:** операции выполняются с неизменяемыми копиями (каждый вызов возвращает новую коллекцию).

## Результаты измерений

### List\<int\>

| Операция              | Среднее время, мс |
| --------------------- | ----------------: |
| Добавление в конец    |              0.63 |
| Добавление в начало   |            176.62 |
| Добавление в середину |             84.15 |
| Удаление из начала    |            111.94 |
| Удаление с конца      |              0.27 |
| Удаление из середины  |             46.08 |
| Поиск по значению     |             95.53 |
| Доступ по индексу     |              0.26 |

### LinkedList\<int\>

| Операция              | Среднее время, мс |
| --------------------- | ----------------: |
| Добавление в конец    |              2.48 |
| Добавление в начало   |              0.65 |
| Добавление в середину |           1026.71 |
| Удаление из начала    |              0.41 |
| Удаление с конца      |              0.36 |
| Удаление из середины  |            816.37 |
| Поиск по значению     |           1333.88 |
| Доступ по индексу     |            930.55 |

### Queue\<int\>

| Операция                     | Среднее время, мс |
| ---------------------------- | ----------------: |
| Добавление (enqueue)         |              0.54 |
| Добавление в начало          |               N/A |
| Добавление в середину        |               N/A |
| Удаление из начала (dequeue) |              0.25 |
| Удаление с конца             |               N/A |
| Удаление из середины         |               N/A |
| Поиск по значению            |             49.39 |
| Доступ по индексу            |               N/A |

### Stack\<int\>

| Операция              | Среднее время, мс |
| --------------------- | ----------------: |
| Добавление (push)     |              1.11 |
| Добавление в начало   |               N/A |
| Добавление в середину |               N/A |
| Удаление (pop)        |              0.32 |
| Удаление с конца      |               N/A |
| Удаление из середины  |               N/A |
| Поиск по значению     |             29.71 |
| Доступ по индексу     |               N/A |

### ImmutableList\<int\>

| Операция              | Среднее время, мс |
| --------------------- | ----------------: |
| Добавление в конец    |             27.61 |
| Добавление в начало   |             27.03 |
| Добавление в середину |             19.58 |
| Удаление из начала    |             17.47 |
| Удаление с конца      |             15.89 |
| Удаление из середины  |             19.92 |
| Поиск по значению     |           3468.86 |
| Доступ по индексу     |              0.40 |

## Анализ и выводы

1. **List<T>** демонстрирует ожидаемое поведение: операции на хвосте O(1) амортизированно, вставки/удаления в начале и середине существенно медленнее.
2. **LinkedList<T>** эффективен при операциях на концах, но любые операции, требующие обхода (середина, поиск, доступ по индексу), резко проигрывают по времени.
3. **Queue<T>** и **Stack<T>** обеспечивают предсказуемые O(1) операции в своих специальных сценариях (FIFO/LIFO), но не поддерживают произвольные вставки и удаление из середины.
4. **ImmutableList<T>** стабильно проигрывает по времени модифицируемым коллекциям из-за копирования структур, но предоставляет гарантии неизменяемости и хорошую локальность чтения.

## Рекомендации

- Использовать `List<T>` для типовых сценариев с частым доступом по индексу и добавлением в конец.
- Выбирать `LinkedList<T>` только при необходимости частых вставок/удалений на концах без произвольного доступа.
- Применять `Queue<T>` и `Stack<T>` в строго FIFO/LIFO типах задач.
- `ImmutableList<T>` оправдан при работе в многопоточном/функциональном стиле, когда важна неизменяемость и лёгкое создание «снимков».
