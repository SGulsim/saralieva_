1. **Можно ли открывать файл несколько раз одновременно?**  
   Желательно избегать параллельного открытия одного и того же файла на запись. Используйте `FileShare` для управления доступом и открывайте файл в `using`, чтобы гарантировать закрытие дескриптора перед повторным использованием.

2. **Когда выбирать `FileMode.Open`, а когда `FileMode.Create`?**  
   `FileMode.Open` предназначен для существующих файлов и бросит исключение, если файл отсутствует. `FileMode.Create` создаёт новый файл или перезаписывает существующий. Для дозаписи применяют `FileMode.Append`.

3. **Нужно ли явно закрывать `StreamWriter`, если он обёрнут вокруг `FileStream`?**  
   Нет, достаточно вызвать `Dispose`/`using` у внешнего писателя. Он закроет и себя, и базовый `FileStream`.

4. **Как действовать, если файл занят другим процессом?**  
   Перехватывайте `IOException`, анализируйте код ошибки и реализуйте повтор с задержкой либо покажите пользователю уведомление. При необходимости используйте блокировки (`FileShare.None`).

5. **Нужна ли защита от одновременной записи при работе из нескольких потоков?**  
   Да, при конкурентной записи применяйте синхронизацию (`lock`, `SemaphoreSlim` или файловые мьютексы) и транзакционные стратегии (временный файл + переименование).

6. **Как проверять корректность пути?**  
   Используйте `Path.GetInvalidPathChars()` и `Path.GetInvalidFileNameChars()`, а также `Path.GetFullPath` с обработкой `ArgumentException`/`NotSupportedException`.

7. **Следует ли переиспользовать `JsonSerializerOptions`?**  
   Да, объекты `JsonSerializerOptions` потокобезопасны для чтения. Создайте один экземпляр и переиспользуйте, как сделано в `PersonSerializer`.

8. **Нужно ли очищать файл перед дозаписью?**  
   Нет, при дозаписи используйте `FileMode.Append` или `FileResourceManager.AppendText`, чтобы добавить данные в конец, не нарушая существующее содержимое.

9. **Стоит ли помечать свойство `Password` атрибутом `[JsonIgnore]`?**  
   Да, чтобы конфиденциальные данные не попадали в сериализованный JSON. В классе `Person` атрибут уже применён.

10. **Когда вызывать `Dispose()` вручную?**  
    Если объект имеет более широкий жизненный цикл, чем конструкция `using`, и вы хотите освободить ресурсы раньше сборки мусора. В противном случае достаточно `using`.

11. **Нужно ли дополнительно вызывать `Dispose()`, если используется `using`?**  
    Нет, оператор `using` автоматически вызывает `Dispose()` по завершении блока (или при исключении).

12. **Зачем проверять флаг `disposing` в `Dispose(bool disposing)`?**  
    Чтобы разделить освобождение управляемых ресурсов (только при `disposing == true`) и неуправляемых (как при `Dispose`, так и из финализатора).

13. **Для чего нужен `GC.SuppressFinalize(this)`?**  
    Чтобы отменить вызов финализатора после явного освобождения ресурсов. Это снижает накладные расходы сборщика мусора и предотвращает повторное освобождение.
